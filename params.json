{
  "name": "Aggregate Functions",
  "tagline": "MariaDB server is a community developed fork of MySQL server. Started by core members of the original MySQL team, MariaDB actively works with outside developers to deliver the most featureful, stable, and sanely licensed open SQL server in the industry.",
  "body": "## **Introduction**\r\n\r\nMost of the current databases like Oracle, PostgreSQL, HSQL support the notion of CREATING AGGREGATE FUNCTIONS . This notion is missing from MariaDB, so this project deals with creating the support for aggregate functions for MariaDB. To incorporate the support for the aggregate stored functions first we had to form the syntax for these functions and then a design plan on how we are going to implement these functions. \r\n\r\n## **Milestones**\r\n\r\n### Added the syntax for the Aggregate Functions to the parser\r\n\r\n*  **Added the AGGREGATE symbol** to the parser. A test has been written to check that the parser parses the AGGREGATE keyword correctly.\r\n\r\n   Link to the [commit](https://github.com/MariaDB/server/commit/dbff33cc32ec0c4a90327a7c91a930b34e16e4f3)\r\n\r\n*  **Added the FETCH GROUP NEXT ROW instruction**: This instruction is exclusive for aggregate functions.This instruction is added to make a temporary exit from the function execution. After the temporary exit is made the values are set to the parameters of the function\r\nand then the function resumes execution.\r\n\r\n   Link to the [commit](https://github.com/MariaDB/server/commit/65782a2a6b5ad3db466953b6ea46f87de2616723)\r\n   \r\n*  **Added an agg_type field to the st_sp_chistics**. This has been added to help us store in the mysql.proc table whether a function is aggregate, window or normal function.\r\n\r\n   Link to the [type aggregate_type.]\r\n (https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sql_lex.h#L170-L176)\r\n\r\n   Link to the field added to the [st_sp_chistics.] \r\n(https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sql_lex.h#L1104-L1111)\r\n\r\n*  **Alter and Create Aggregate functions**:\r\nThe CREATE FUNCTION query should store if the function is an aggregate/window/normal function in the aggregate\r\nfield of the mysql.proc table.\r\nAlter query should allow user to change the aggregate field of the mysql.proc table.\r\n\r\n   [create function, ] (https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp.cc#L1236-L1239) \r\n[alter function] (https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp.cc#L1547-L1549)\r\n\r\n   [test for the create and alter queries] (https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/mysql-test/t/aggregate_show_create_alter.test),  [result](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/mysql-test/r/aggregate_show_create_alter.result)\r\n\r\n\r\n### Added the implementation of the Item_sum_sp class\r\nThis [class](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1104-L1189) is inherited from the Item_sum class.This class mainly deals with the concept of making an interface which allows user to execute aggregate functions.For executing the\r\naggregate functions we have taken a special cursor approach.\r\n\r\n1. **Cursor Approach**:\r\nA new instruction FETCH GROUP NEXT ROW instruction is introduced. This instruction handles the state the aggregate function is currently in.\r\nThere is a field pause_state in the class sp_context. \r\n\r\n   *  **pause_state is [TRUE](https://github.com/varunraiko/aggregate-functions/blob/aggregate-   functions/sql/sp_head.cc#L4566-L4569)**: In this case, the function enters the pause state and we save the\r\n   state of the function. The instruction pointer(instr_ptr) continues to point to the FETCH GROUP NEXT ROW\r\n   instruction, and the function makes a temporary pause in its execution and that the state of the\r\n   function is saved. The function is paused so that next row values can be set for the function's\r\n   arguments. After the values are passed to the arguments the function resumes execution.\r\n\r\n   *  **pause_state is [FALSE](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L4570-L4582)**: In this case, the function exits from the pause state and resumes\r\n   execution. The instruction pointer(instr_ptr) is then incremented and now it points to the next\r\n   instruction to be executed.\r\n\r\n\r\n2. **[Item_sum_sp::add()](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1577-L1587) function added**: This function handles everything that is done regarding the aggregation of values.\r\n\r\n   *  **[Item_sum_sp::execute_impl()](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1518-L1565)**: Execute function and store the return value in the field. This is called from the add() function to aggregate the values and from execute() to return the value in the sp_result_field(field defined in the Item_sum_sp class).\r\n\r\n   *  **[sp_head::execute_aggregate_function()](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2357-L2585)**: This function is called from the execute_impl function. In this function the run-time context([func_ctx](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1112)) is created. I have followed a different approach when the function fetches the row so as to set the values to the parameters. When we call the function for the first time(that is when the first row is fetched), the run-time context is [created](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2405-L2410) but the values to the arguments are not set. These values are set when we encounter a FETCH GROUP NEXT ROW instruction and pause the aggregate function. Then after the pause, the values to the [parameters are set](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2519-L2529) and the function resumes execution. For the next fetch we don't need to create the context as we preserve the earlier run-time context([func_ctx](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1112)). The values to the [parameter are set](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2420-L2429) straight away and then the rest of the instructions are executed.    \r\n\r\n3. **[Item_sum_sp::val_xxx()](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1142-L1180) functions added**: This function gets the return value for the current aggregate function and stores the value in the result field. A signal is send in the field [server_status](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1488). The value for server status is set to SERVER_STATUS_LAST_ROW_SENT. This implies that all the rows have been fetched and now we need to throw an error that there is no more data ([ER_SP_FETCH_NO_DATA](https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L4574-L4579)), so this error is handled by the handler. The handler handles the error and the function execution is complete.\r\n\r\n### [**All Commits**](https://github.com/varunraiko/aggregate-functions/commits/aggregate-functions?author=varunraiko)\r\n    ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}