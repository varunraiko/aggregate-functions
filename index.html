<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Aggregate Functions by varunraiko</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Aggregate Functions</h1>
      <h2 class="project-tagline">MariaDB server is a community developed fork of MySQL server. Started by core members of the original MySQL team, MariaDB actively works with outside developers to deliver the most featureful, stable, and sanely licensed open SQL server in the industry.</h2>
      <a href="https://github.com/varunraiko/aggregate-functions" class="btn">View on GitHub</a>
      <a href="https://github.com/varunraiko/aggregate-functions/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/varunraiko/aggregate-functions/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Introduction</strong>
</h2>

<p>Most of the current databases like Oracle, PostgreSQL, HSQL support the notion of CREATING AGGREGATE FUNCTIONS . This notion is missing from MariaDB, so this project deals with creating the support for aggregate functions for MariaDB. To incorporate the support for the aggregate stored functions first we had to form the syntax for these functions and then a design plan on how we are going to implement these functions. </p>

<h2>
<a id="milestones" class="anchor" href="#milestones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Milestones</strong>
</h2>

<h3>
<a id="added-the-syntax-for-the-aggregate-functions-to-the-parser" class="anchor" href="#added-the-syntax-for-the-aggregate-functions-to-the-parser" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Added the syntax for the Aggregate Functions to the parser</h3>

<ul>
<li>
<p><strong>Added the AGGREGATE symbol</strong> to the parser. A test has been written to check that the parser parses the AGGREGATE keyword correctly.</p>

<p>Link to the <a href="https://github.com/MariaDB/server/commit/dbff33cc32ec0c4a90327a7c91a930b34e16e4f3">commit</a></p>
</li>
<li>
<p><strong>Added the FETCH GROUP NEXT ROW instruction</strong>: This instruction is exclusive for aggregate functions.This instruction is added to make a temporary exit from the function execution. After the temporary exit is made the values are set to the parameters of the function
and then the function resumes execution.</p>

<p>Link to the <a href="https://github.com/MariaDB/server/commit/65782a2a6b5ad3db466953b6ea46f87de2616723">commit</a></p>
</li>
<li>
<p><strong>Added an agg_type field to the st_sp_chistics</strong>. This has been added to help us store in the mysql.proc table whether a function is aggregate, window or normal function.</p>

<p>Link to the <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sql_lex.h#L170-L176">type aggregate_type.</a></p>

<p>Link to the field added to the <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sql_lex.h#L1104-L1111">st_sp_chistics.</a></p>
</li>
<li>
<p><strong>Alter and Create Aggregate functions</strong>:
The CREATE FUNCTION query should store if the function is an aggregate/window/normal function in the aggregate
field of the mysql.proc table.
Alter query should allow user to change the aggregate field of the mysql.proc table.</p>

<p><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp.cc#L1236-L1239">create function, </a> 
<a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp.cc#L1547-L1549">alter function</a></p>

<p><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/mysql-test/t/aggregate_show_create_alter.test">test for the create and alter queries</a>,  <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/mysql-test/r/aggregate_show_create_alter.result">result</a></p>
</li>
</ul>

<h3>
<a id="added-the-implementation-of-the-item_sum_sp-class" class="anchor" href="#added-the-implementation-of-the-item_sum_sp-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Added the implementation of the Item_sum_sp class</h3>

<p>This <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1104-L1189">class</a> is inherited from the Item_sum class.This class mainly deals with the concept of making an interface which allows user to execute aggregate functions.For executing the
aggregate functions we have taken a special cursor approach.</p>

<ol>
<li>
<p><strong>Cursor Approach</strong>:
A new instruction FETCH GROUP NEXT ROW instruction is introduced. This instruction handles the state the aggregate function is currently in.
There is a field pause_state in the class sp_context. </p>

<ul>
<li><p><strong>pause_state is <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-%20%20%20functions/sql/sp_head.cc#L4566-L4569">TRUE</a></strong>: In this case, the function enters the pause state and we save the
state of the function. The instruction pointer(instr_ptr) continues to point to the FETCH GROUP NEXT ROW
instruction, and the function makes a temporary pause in its execution and that the state of the
function is saved. The function is paused so that next row values can be set for the function's
arguments. After the values are passed to the arguments the function resumes execution.</p></li>
<li><p><strong>pause_state is <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L4570-L4582">FALSE</a></strong>: In this case, the function exits from the pause state and resumes
execution. The instruction pointer(instr_ptr) is then incremented and now it points to the next
instruction to be executed.</p></li>
</ul>
</li>
<li>
<p><strong><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1577-L1587">Item_sum_sp::add()</a> function added</strong>: This function handles everything that is done regarding the aggregation of values.</p>

<ul>
<li><p><strong><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1518-L1565">Item_sum_sp::execute_impl()</a></strong>: Execute function and store the return value in the field. This is called from the add() function to aggregate the values and from execute() to return the value in the sp_result_field(field defined in the Item_sum_sp class).</p></li>
<li><p><strong><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2357-L2585">sp_head::execute_aggregate_function()</a></strong>: This function is called from the execute_impl function. In this function the run-time context(<a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1112">func_ctx</a>) is created. I have followed a different approach when the function fetches the row so as to set the values to the parameters. When we call the function for the first time(that is when the first row is fetched), the run-time context is <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2405-L2410">created</a> but the values to the arguments are not set. These values are set when we encounter a FETCH GROUP NEXT ROW instruction and pause the aggregate function. Then after the pause, the values to the <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2519-L2529">parameters are set</a> and the function resumes execution. For the next fetch we don't need to create the context as we preserve the earlier run-time context(<a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1112">func_ctx</a>). The values to the <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L2420-L2429">parameter are set</a> straight away and then the rest of the instructions are executed.    </p></li>
</ul>
</li>
<li><p><strong><a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.h#L1142-L1180">Item_sum_sp::val_xxx()</a> functions added</strong>: This function gets the return value for the current aggregate function and stores the value in the result field. A signal is send in the field <a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/item_sum.cc#L1488">server_status</a>. The value for server status is set to SERVER_STATUS_LAST_ROW_SENT. This implies that all the rows have been fetched and now we need to throw an error that there is no more data (<a href="https://github.com/varunraiko/aggregate-functions/blob/aggregate-functions/sql/sp_head.cc#L4574-L4579">ER_SP_FETCH_NO_DATA</a>), so this error is handled by the handler. The handler handles the error and the function execution is complete.</p></li>
</ol>

<p><strong>FEW EXAMPLES</strong>
Well now lets see some examples to understand how these functions work.</p>

<p>CREATE AGGREGATE FUNCTION function_name (parameters) RETURNS return_type
BEGIN
      All types of declarations
      DECLARE CONTINUE HANDLER FOR NOT FOUND RETURN return_val;
      LOOP
       FETCH GROUP NEXT ROW; 
       Some instructions
      END LOOP;
END|</p>

<p>This would be the syntax and structure for the aggregate functions.
<strong>FETCH GROUP NEXT ROW</strong> is the essential instruction for the aggregate. It fetches the next row of the table. It is by this instruction the values to the parameters are set.</p>

<p>So let us say we take an example where we have a table which contains details about a student and his/her marks in two subjects( Subject A and Subject B). 
Our table MARKS would have the fields ( Student, Roll Number, Marks in Subject A, Marks in Subject B), with Roll Number as the primary key</p>

<p>So we need to find the answer to few queries</p>

<p><strong>Find the number of students in the class.</strong>
For this query , we can create an aggregate function to count the number of entries in the table.
Let us name the function , aggregate_count and it accepts one parameter that is Roll Number.</p>

<p>CREATE AGGREGATE FUNCTION aggregate_count(x DOUBLE) RETURNS INT
BEGIN
      DECLARE  count_students INT DEFAULT 0;
      DECLARE CONTINUE HANDLER FOR NOT FOUND RETURN count_students;<br>
      LOOP
       FETCH GROUP NEXT ROW;
       IF x  THEN
       SET count_students = count_students+1;
       END IF;
      END LOOP;
END|</p>

<p>The query to get the answer would be:
         SELECT aggregate_count(roll_number) from MARKS;</p>

<p><strong>Find the total marks scored by all students in Subject A</strong>
For this query we can create an aggregate function to calculate the total sum of marks of all the student for the Subject A.
Let us name the function total_sum, with parameters marks of a subject.</p>

<p>CREATE AGGREGATE FUNCTION aggregate_total_sum(x DOUBLE) RETURNS INT
BEGIN
      DECLARE  total_marks INT DEFAULT 0;
      DECLARE CONTINUE HANDLER FOR NOT FOUND RETURN count_students;<br>
      LOOP
       FETCH GROUP NEXT ROW;
       SET total_marks = total_marks+x;
      END LOOP;
END|</p>

<p>SELECT aggregate_total_sum(marks_A) from MARKS;</p>

<p><strong>Find the average marks of the class(including both subjects)</strong>
We can perform this query in various cases. We can create another aggregate function that would calculate the average of the marks in both the subject or we could use the aggregate functions defined above, calling them from normal functions.</p>

<p>CREATE FUNCTION average() RETURNS DOUBLE
BEGIN<br>
       DECLARE  total_marks INT DEFAULT 0;
       DECLARE  count_students INT DEFAULT 0;
       SET count_students= (SELECT aggregate_count(roll_number) from MARKS);
       SET total_marks= (SELECT aggregate_total_sum(marks_A) from MARKS)+
                                     (SELECT aggregate_total_sum(marks_B) from MARKS);
      IF count_students = 0 then
             RETURN 0;
      ELSE 
            RETURN total_marks/count_students;
      END IF;
END|</p>

<p>Select average();</p>

<h3>
<a id="all-commits" class="anchor" href="#all-commits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/varunraiko/aggregate-functions/commits/aggregate-functions?author=varunraiko"><strong>All Commits</strong></a>
</h3>

<h3>
<a id="complete-diff-file" class="anchor" href="#complete-diff-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong><a href="https://www.dropbox.com/s/o44wiq8rifd2e57/diff.txt?dl=0">Complete diff file</a></strong>
</h3>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/varunraiko/aggregate-functions">Aggregate Functions</a> is maintained by <a href="https://github.com/varunraiko">varunraiko</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
